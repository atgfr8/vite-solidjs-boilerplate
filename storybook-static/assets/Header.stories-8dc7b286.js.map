{"version":3,"file":"Header.stories-8dc7b286.js","sources":["../../node_modules/@solidjs/router/dist/integration.js","../../node_modules/@solidjs/router/dist/lifecycle.js","../../node_modules/@solidjs/router/dist/utils.js","../../node_modules/@solidjs/router/dist/routing.js","../../node_modules/@solidjs/router/dist/components.jsx","../../src/assets/atgLogo.png","../../src/components/Header/Header.tsx"],"sourcesContent":["import { createSignal, onCleanup } from \"solid-js\";\nfunction bindEvent(target, type, handler) {\n    target.addEventListener(type, handler);\n    return () => target.removeEventListener(type, handler);\n}\nfunction intercept([value, setValue], get, set) {\n    return [get ? () => get(value()) : value, set ? (v) => setValue(set(v)) : setValue];\n}\nfunction querySelector(selector) {\n    // Guard against selector being an invalid CSS selector\n    try {\n        return document.querySelector(selector);\n    }\n    catch (e) {\n        return null;\n    }\n}\nfunction scrollToHash(hash, fallbackTop) {\n    const el = querySelector(`#${hash}`);\n    if (el) {\n        el.scrollIntoView();\n    }\n    else if (fallbackTop) {\n        window.scrollTo(0, 0);\n    }\n}\nexport function createMemoryHistory() {\n    const entries = [\"/\"];\n    let index = 0;\n    const listeners = [];\n    const go = (n) => {\n        // https://github.com/remix-run/react-router/blob/682810ca929d0e3c64a76f8d6e465196b7a2ac58/packages/router/history.ts#L245\n        index = Math.max(0, Math.min(index + n, entries.length - 1));\n        const value = entries[index];\n        listeners.forEach(listener => listener(value));\n    };\n    return {\n        get: () => entries[index],\n        set: ({ value, scroll, replace }) => {\n            if (replace) {\n                entries[index] = value;\n            }\n            else {\n                entries.splice(index + 1, entries.length - index, value);\n                index++;\n            }\n            if (scroll) {\n                scrollToHash(value.split(\"#\")[1] || \"\", true);\n            }\n        },\n        back: () => {\n            go(-1);\n        },\n        forward: () => {\n            go(1);\n        },\n        go,\n        listen: (listener) => {\n            listeners.push(listener);\n            return () => {\n                const index = listeners.indexOf(listener);\n                listeners.splice(index, 1);\n            };\n        }\n    };\n}\nexport function createIntegration(get, set, init, utils) {\n    let ignore = false;\n    const wrap = (value) => (typeof value === \"string\" ? { value } : value);\n    const signal = intercept(createSignal(wrap(get()), { equals: (a, b) => a.value === b.value }), undefined, next => {\n        !ignore && set(next);\n        return next;\n    });\n    init &&\n        onCleanup(init((value = get()) => {\n            ignore = true;\n            signal[1](wrap(value));\n            ignore = false;\n        }));\n    return {\n        signal,\n        utils\n    };\n}\nexport function normalizeIntegration(integration) {\n    if (!integration) {\n        return {\n            signal: createSignal({ value: \"\" })\n        };\n    }\n    else if (Array.isArray(integration)) {\n        return {\n            signal: integration\n        };\n    }\n    return integration;\n}\nexport function staticIntegration(obj) {\n    return {\n        signal: [() => obj, next => Object.assign(obj, next)]\n    };\n}\nexport function pathIntegration() {\n    return createIntegration(() => ({\n        value: window.location.pathname + window.location.search + window.location.hash,\n        state: history.state\n    }), ({ value, replace, scroll, state }) => {\n        if (replace) {\n            window.history.replaceState(state, \"\", value);\n        }\n        else {\n            window.history.pushState(state, \"\", value);\n        }\n        scrollToHash(window.location.hash.slice(1), scroll);\n    }, notify => bindEvent(window, \"popstate\", () => notify()), {\n        go: delta => window.history.go(delta)\n    });\n}\nexport function hashIntegration() {\n    return createIntegration(() => window.location.hash.slice(1), ({ value, replace, scroll, state }) => {\n        if (replace) {\n            window.history.replaceState(state, \"\", \"#\" + value);\n        }\n        else {\n            window.location.hash = value;\n        }\n        const hashIndex = value.indexOf(\"#\");\n        const hash = hashIndex >= 0 ? value.slice(hashIndex + 1) : \"\";\n        scrollToHash(hash, scroll);\n    }, notify => bindEvent(window, \"hashchange\", () => notify()), {\n        go: delta => window.history.go(delta),\n        renderPath: path => `#${path}`,\n        parsePath: str => {\n            const to = str.replace(/^.*?#/, \"\");\n            // Hash-only hrefs like `#foo` from plain anchors will come in as `/#foo` whereas a link to\n            // `/foo` will be `/#/foo`. Check if the to starts with a `/` and if not append it as a hash\n            // to the current path so we can handle these in-page anchors correctly.\n            if (!to.startsWith(\"/\")) {\n                const [, path = \"/\"] = window.location.hash.split(\"#\", 2);\n                return `${path}#${to}`;\n            }\n            return to;\n        }\n    });\n}\nexport function memoryIntegration() {\n    const memoryHistory = createMemoryHistory();\n    return createIntegration(memoryHistory.get, memoryHistory.set, memoryHistory.listen, {\n        go: memoryHistory.go\n    });\n}\n","export function createBeforeLeave() {\n    let listeners = new Set();\n    function subscribe(listener) {\n        listeners.add(listener);\n        return () => listeners.delete(listener);\n    }\n    let ignore = false;\n    function confirm(to, options) {\n        if (ignore)\n            return !(ignore = false);\n        const e = {\n            to,\n            options,\n            defaultPrevented: false,\n            preventDefault: () => (e.defaultPrevented = true)\n        };\n        for (const l of listeners)\n            l.listener({\n                ...e,\n                from: l.location,\n                retry: (force) => {\n                    force && (ignore = true);\n                    l.navigate(to, options);\n                }\n            });\n        return !e.defaultPrevented;\n    }\n    return {\n        subscribe,\n        confirm\n    };\n}\n","import { createMemo, getOwner, runWithOwner } from \"solid-js\";\nconst hasSchemeRegex = /^(?:[a-z0-9]+:)?\\/\\//i;\nconst trimPathRegex = /^\\/+|(\\/)\\/+$/g;\nexport function normalizePath(path, omitSlash = false) {\n    const s = path.replace(trimPathRegex, \"$1\");\n    return s ? (omitSlash || /^[?#]/.test(s) ? s : \"/\" + s) : \"\";\n}\nexport function resolvePath(base, path, from) {\n    if (hasSchemeRegex.test(path)) {\n        return undefined;\n    }\n    const basePath = normalizePath(base);\n    const fromPath = from && normalizePath(from);\n    let result = \"\";\n    if (!fromPath || path.startsWith(\"/\")) {\n        result = basePath;\n    }\n    else if (fromPath.toLowerCase().indexOf(basePath.toLowerCase()) !== 0) {\n        result = basePath + fromPath;\n    }\n    else {\n        result = fromPath;\n    }\n    return (result || \"/\") + normalizePath(path, !result);\n}\nexport function invariant(value, message) {\n    if (value == null) {\n        throw new Error(message);\n    }\n    return value;\n}\nexport function joinPaths(from, to) {\n    return normalizePath(from).replace(/\\/*(\\*.*)?$/g, \"\") + normalizePath(to);\n}\nexport function extractSearchParams(url) {\n    const params = {};\n    url.searchParams.forEach((value, key) => {\n        params[key] = value;\n    });\n    return params;\n}\nexport function createMatcher(path, partial, matchFilters) {\n    const [pattern, splat] = path.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    const len = segments.length;\n    return (location) => {\n        const locSegments = location.split(\"/\").filter(Boolean);\n        const lenDiff = locSegments.length - len;\n        if (lenDiff < 0 || (lenDiff > 0 && splat === undefined && !partial)) {\n            return null;\n        }\n        const match = {\n            path: len ? \"\" : \"/\",\n            params: {}\n        };\n        const matchFilter = (s) => matchFilters === undefined ? undefined : matchFilters[s];\n        for (let i = 0; i < len; i++) {\n            const segment = segments[i];\n            const locSegment = locSegments[i];\n            const dynamic = segment[0] === \":\";\n            const key = dynamic ? segment.slice(1) : segment;\n            if (dynamic && matchSegment(locSegment, matchFilter(key))) {\n                match.params[key] = locSegment;\n            }\n            else if (dynamic || !matchSegment(locSegment, segment)) {\n                return null;\n            }\n            match.path += `/${locSegment}`;\n        }\n        if (splat) {\n            const remainder = lenDiff ? locSegments.slice(-lenDiff).join(\"/\") : \"\";\n            if (matchSegment(remainder, matchFilter(splat))) {\n                match.params[splat] = remainder;\n            }\n            else {\n                return null;\n            }\n        }\n        return match;\n    };\n}\nfunction matchSegment(input, filter) {\n    const isEqual = (s) => s.localeCompare(input, undefined, { sensitivity: \"base\" }) === 0;\n    if (filter === undefined) {\n        return true;\n    }\n    else if (typeof filter === \"string\") {\n        return isEqual(filter);\n    }\n    else if (typeof filter === \"function\") {\n        return filter(input);\n    }\n    else if (Array.isArray(filter)) {\n        return filter.some(isEqual);\n    }\n    else if (filter instanceof RegExp) {\n        return filter.test(input);\n    }\n    return false;\n}\nexport function scoreRoute(route) {\n    const [pattern, splat] = route.pattern.split(\"/*\", 2);\n    const segments = pattern.split(\"/\").filter(Boolean);\n    return segments.reduce((score, segment) => score + (segment.startsWith(\":\") ? 2 : 3), segments.length - (splat === undefined ? 0 : 1));\n}\nexport function createMemoObject(fn) {\n    const map = new Map();\n    const owner = getOwner();\n    return new Proxy({}, {\n        get(_, property) {\n            if (!map.has(property)) {\n                runWithOwner(owner, () => map.set(property, createMemo(() => fn()[property])));\n            }\n            return map.get(property)();\n        },\n        getOwnPropertyDescriptor() {\n            return {\n                enumerable: true,\n                configurable: true\n            };\n        },\n        ownKeys() {\n            return Reflect.ownKeys(fn());\n        }\n    });\n}\nexport function mergeSearchString(search, params) {\n    const merged = new URLSearchParams(search);\n    Object.entries(params).forEach(([key, value]) => {\n        if (value == null || value === \"\") {\n            merged.delete(key);\n        }\n        else {\n            merged.set(key, String(value));\n        }\n    });\n    const s = merged.toString();\n    return s ? `?${s}` : \"\";\n}\nexport function expandOptionals(pattern) {\n    let match = /(\\/?\\:[^\\/]+)\\?/.exec(pattern);\n    if (!match)\n        return [pattern];\n    let prefix = pattern.slice(0, match.index);\n    let suffix = pattern.slice(match.index + match[0].length);\n    const prefixes = [prefix, (prefix += match[1])];\n    // This section handles adjacent optional params. We don't actually want all permuations since\n    // that will lead to equivalent routes which have the same number of params. For example\n    // `/:a?/:b?/:c`? only has the unique expansion: `/`, `/:a`, `/:a/:b`, `/:a/:b/:c` and we can\n    // discard `/:b`, `/:c`, `/:b/:c` by building them up in order and not recursing. This also helps\n    // ensure predictability where earlier params have precidence.\n    while ((match = /^(\\/\\:[^\\/]+)\\?/.exec(suffix))) {\n        prefixes.push((prefix += match[1]));\n        suffix = suffix.slice(match[0].length);\n    }\n    return expandOptionals(suffix).reduce((results, expansion) => [...results, ...prefixes.map(p => p + expansion)], []);\n}\n","import { createComponent, createContext, createMemo, createRenderEffect, createSignal, on, onCleanup, untrack, useContext, startTransition, resetErrorBoundaries } from \"solid-js\";\nimport { isServer, delegateEvents } from \"solid-js/web\";\nimport { normalizeIntegration } from \"./integration\";\nimport { createBeforeLeave } from \"./lifecycle\";\nimport { createMemoObject, extractSearchParams, invariant, resolvePath, createMatcher, joinPaths, scoreRoute, mergeSearchString, expandOptionals } from \"./utils\";\nconst MAX_REDIRECTS = 100;\nexport const RouterContextObj = createContext();\nexport const RouteContextObj = createContext();\nexport const useRouter = () => invariant(useContext(RouterContextObj), \"Make sure your app is wrapped in a <Router />\");\nlet TempRoute;\nexport const useRoute = () => TempRoute || useContext(RouteContextObj) || useRouter().base;\nexport const useResolvedPath = (path) => {\n    const route = useRoute();\n    return createMemo(() => route.resolvePath(path()));\n};\nexport const useHref = (to) => {\n    const router = useRouter();\n    return createMemo(() => {\n        const to_ = to();\n        return to_ !== undefined ? router.renderPath(to_) : to_;\n    });\n};\nexport const useNavigate = () => useRouter().navigatorFactory();\nexport const useLocation = () => useRouter().location;\nexport const useIsRouting = () => useRouter().isRouting;\nexport const useMatch = (path, matchFilters) => {\n    const location = useLocation();\n    const matchers = createMemo(() => expandOptionals(path()).map(path => createMatcher(path, undefined, matchFilters)));\n    return createMemo(() => {\n        for (const matcher of matchers()) {\n            const match = matcher(location.pathname);\n            if (match)\n                return match;\n        }\n    });\n};\nexport const useParams = () => useRoute().params;\nexport const useRouteData = () => useRoute().data;\nexport const useSearchParams = () => {\n    const location = useLocation();\n    const navigate = useNavigate();\n    const setSearchParams = (params, options) => {\n        const searchString = untrack(() => location.pathname + mergeSearchString(location.search, params) + location.hash);\n        navigate(searchString, {\n            scroll: false,\n            resolve: false,\n            ...options\n        });\n    };\n    return [location.query, setSearchParams];\n};\nexport const useBeforeLeave = (listener) => {\n    const s = useRouter().beforeLeave.subscribe({\n        listener,\n        location: useLocation(),\n        navigate: useNavigate()\n    });\n    onCleanup(s);\n};\nexport function createRoutes(routeDef, base = \"\", fallback) {\n    const { component, data, children } = routeDef;\n    const isLeaf = !children || (Array.isArray(children) && !children.length);\n    const shared = {\n        key: routeDef,\n        element: component\n            ? () => createComponent(component, {})\n            : () => {\n                const { element } = routeDef;\n                return element === undefined && fallback\n                    ? createComponent(fallback, {})\n                    : element;\n            },\n        preload: routeDef.component\n            ? component.preload\n            : routeDef.preload,\n        data\n    };\n    return asArray(routeDef.path).reduce((acc, path) => {\n        for (const originalPath of expandOptionals(path)) {\n            const path = joinPaths(base, originalPath);\n            const pattern = isLeaf ? path : path.split(\"/*\", 1)[0];\n            acc.push({\n                ...shared,\n                originalPath,\n                pattern,\n                matcher: createMatcher(pattern, !isLeaf, routeDef.matchFilters)\n            });\n        }\n        return acc;\n    }, []);\n}\nexport function createBranch(routes, index = 0) {\n    return {\n        routes,\n        score: scoreRoute(routes[routes.length - 1]) * 10000 - index,\n        matcher(location) {\n            const matches = [];\n            for (let i = routes.length - 1; i >= 0; i--) {\n                const route = routes[i];\n                const match = route.matcher(location);\n                if (!match) {\n                    return null;\n                }\n                matches.unshift({\n                    ...match,\n                    route\n                });\n            }\n            return matches;\n        }\n    };\n}\nfunction asArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\nexport function createBranches(routeDef, base = \"\", fallback, stack = [], branches = []) {\n    const routeDefs = asArray(routeDef);\n    for (let i = 0, len = routeDefs.length; i < len; i++) {\n        const def = routeDefs[i];\n        if (def && typeof def === \"object\" && def.hasOwnProperty(\"path\")) {\n            const routes = createRoutes(def, base, fallback);\n            for (const route of routes) {\n                stack.push(route);\n                const isEmptyArray = Array.isArray(def.children) && def.children.length === 0;\n                if (def.children && !isEmptyArray) {\n                    createBranches(def.children, route.pattern, fallback, stack, branches);\n                }\n                else {\n                    const branch = createBranch([...stack], branches.length);\n                    branches.push(branch);\n                }\n                stack.pop();\n            }\n        }\n    }\n    // Stack will be empty on final return\n    return stack.length ? branches : branches.sort((a, b) => b.score - a.score);\n}\nexport function getRouteMatches(branches, location) {\n    for (let i = 0, len = branches.length; i < len; i++) {\n        const match = branches[i].matcher(location);\n        if (match) {\n            return match;\n        }\n    }\n    return [];\n}\nexport function createLocation(path, state) {\n    const origin = new URL(\"http://sar\");\n    const url = createMemo(prev => {\n        const path_ = path();\n        try {\n            return new URL(path_, origin);\n        }\n        catch (err) {\n            console.error(`Invalid path ${path_}`);\n            return prev;\n        }\n    }, origin, {\n        equals: (a, b) => a.href === b.href\n    });\n    const pathname = createMemo(() => url().pathname);\n    const search = createMemo(() => url().search, true);\n    const hash = createMemo(() => url().hash);\n    const key = createMemo(() => \"\");\n    return {\n        get pathname() {\n            return pathname();\n        },\n        get search() {\n            return search();\n        },\n        get hash() {\n            return hash();\n        },\n        get state() {\n            return state();\n        },\n        get key() {\n            return key();\n        },\n        query: createMemoObject(on(search, () => extractSearchParams(url())))\n    };\n}\nexport function createRouterContext(integration, base = \"\", data, out) {\n    const { signal: [source, setSource], utils = {} } = normalizeIntegration(integration);\n    const parsePath = utils.parsePath || (p => p);\n    const renderPath = utils.renderPath || (p => p);\n    const beforeLeave = utils.beforeLeave || createBeforeLeave();\n    const basePath = resolvePath(\"\", base);\n    const output = isServer && out\n        ? Object.assign(out, {\n            matches: [],\n            url: undefined\n        })\n        : undefined;\n    if (basePath === undefined) {\n        throw new Error(`${basePath} is not a valid base path`);\n    }\n    else if (basePath && !source().value) {\n        setSource({ value: basePath, replace: true, scroll: false });\n    }\n    const [isRouting, setIsRouting] = createSignal(false);\n    const start = async (callback) => {\n        setIsRouting(true);\n        try {\n            await startTransition(callback);\n        }\n        finally {\n            setIsRouting(false);\n        }\n    };\n    const [reference, setReference] = createSignal(source().value);\n    const [state, setState] = createSignal(source().state);\n    const location = createLocation(reference, state);\n    const referrers = [];\n    const baseRoute = {\n        pattern: basePath,\n        params: {},\n        path: () => basePath,\n        outlet: () => null,\n        resolvePath(to) {\n            return resolvePath(basePath, to);\n        }\n    };\n    if (data) {\n        try {\n            TempRoute = baseRoute;\n            baseRoute.data = data({\n                data: undefined,\n                params: {},\n                location,\n                navigate: navigatorFactory(baseRoute)\n            });\n        }\n        finally {\n            TempRoute = undefined;\n        }\n    }\n    function navigateFromRoute(route, to, options) {\n        // Untrack in case someone navigates in an effect - don't want to track `reference` or route paths\n        untrack(() => {\n            if (typeof to === \"number\") {\n                if (!to) {\n                    // A delta of 0 means stay at the current location, so it is ignored\n                }\n                else if (utils.go) {\n                    beforeLeave.confirm(to, options) && utils.go(to);\n                }\n                else {\n                    console.warn(\"Router integration does not support relative routing\");\n                }\n                return;\n            }\n            const { replace, resolve, scroll, state: nextState } = {\n                replace: false,\n                resolve: true,\n                scroll: true,\n                ...options\n            };\n            const resolvedTo = resolve ? route.resolvePath(to) : resolvePath(\"\", to);\n            if (resolvedTo === undefined) {\n                throw new Error(`Path '${to}' is not a routable path`);\n            }\n            else if (referrers.length >= MAX_REDIRECTS) {\n                throw new Error(\"Too many redirects\");\n            }\n            const current = reference();\n            if (resolvedTo !== current || nextState !== state()) {\n                if (isServer) {\n                    if (output) {\n                        output.url = resolvedTo;\n                    }\n                    setSource({ value: resolvedTo, replace, scroll, state: nextState });\n                }\n                else if (beforeLeave.confirm(resolvedTo, options)) {\n                    const len = referrers.push({ value: current, replace, scroll, state: state() });\n                    start(() => {\n                        setReference(resolvedTo);\n                        setState(nextState);\n                        resetErrorBoundaries();\n                    }).then(() => {\n                        if (referrers.length === len) {\n                            navigateEnd({\n                                value: resolvedTo,\n                                state: nextState\n                            });\n                        }\n                    });\n                }\n            }\n        });\n    }\n    function navigatorFactory(route) {\n        // Workaround for vite issue (https://github.com/vitejs/vite/issues/3803)\n        route = route || useContext(RouteContextObj) || baseRoute;\n        return (to, options) => navigateFromRoute(route, to, options);\n    }\n    function navigateEnd(next) {\n        const first = referrers[0];\n        if (first) {\n            if (next.value !== first.value || next.state !== first.state) {\n                setSource({\n                    ...next,\n                    replace: first.replace,\n                    scroll: first.scroll\n                });\n            }\n            referrers.length = 0;\n        }\n    }\n    createRenderEffect(() => {\n        const { value, state } = source();\n        // Untrack this whole block so `start` doesn't cause Solid's Listener to be preserved\n        untrack(() => {\n            if (value !== reference()) {\n                start(() => {\n                    setReference(value);\n                    setState(state);\n                });\n            }\n        });\n    });\n    if (!isServer) {\n        function handleAnchorClick(evt) {\n            if (evt.defaultPrevented ||\n                evt.button !== 0 ||\n                evt.metaKey ||\n                evt.altKey ||\n                evt.ctrlKey ||\n                evt.shiftKey)\n                return;\n            const a = evt\n                .composedPath()\n                .find(el => el instanceof Node && el.nodeName.toUpperCase() === \"A\");\n            if (!a || !a.hasAttribute(\"link\"))\n                return;\n            const href = a.href;\n            if (a.target || (!href && !a.hasAttribute(\"state\")))\n                return;\n            const rel = (a.getAttribute(\"rel\") || \"\").split(/\\s+/);\n            if (a.hasAttribute(\"download\") || (rel && rel.includes(\"external\")))\n                return;\n            const url = new URL(href);\n            if (url.origin !== window.location.origin ||\n                (basePath && url.pathname && !url.pathname.toLowerCase().startsWith(basePath.toLowerCase())))\n                return;\n            const to = parsePath(url.pathname + url.search + url.hash);\n            const state = a.getAttribute(\"state\");\n            evt.preventDefault();\n            navigateFromRoute(baseRoute, to, {\n                resolve: false,\n                replace: a.hasAttribute(\"replace\"),\n                scroll: !a.hasAttribute(\"noscroll\"),\n                state: state && JSON.parse(state)\n            });\n        }\n        // ensure delegated events run first\n        delegateEvents([\"click\"]);\n        document.addEventListener(\"click\", handleAnchorClick);\n        onCleanup(() => document.removeEventListener(\"click\", handleAnchorClick));\n    }\n    return {\n        base: baseRoute,\n        out: output,\n        location,\n        isRouting,\n        renderPath,\n        parsePath,\n        navigatorFactory,\n        beforeLeave\n    };\n}\nexport function createRouteContext(router, parent, child, match, params) {\n    const { base, location, navigatorFactory } = router;\n    const { pattern, element: outlet, preload, data } = match().route;\n    const path = createMemo(() => match().path);\n    preload && preload();\n    const route = {\n        parent,\n        pattern,\n        get child() {\n            return child();\n        },\n        path,\n        params,\n        data: parent.data,\n        outlet,\n        resolvePath(to) {\n            return resolvePath(base.path(), to, path());\n        }\n    };\n    if (data) {\n        try {\n            TempRoute = route;\n            route.data = data({ data: parent.data, params, location, navigate: navigatorFactory(route) });\n        }\n        finally {\n            TempRoute = undefined;\n        }\n    }\n    return route;\n}\n","/*@refresh skip*/\nimport { children, createMemo, createRoot, mergeProps, on, Show, splitProps } from \"solid-js\";\nimport { isServer } from \"solid-js/web\";\nimport { pathIntegration, staticIntegration } from \"./integration\";\nimport { createBranches, createRouteContext, createRouterContext, getRouteMatches, RouteContextObj, RouterContextObj, useHref, useLocation, useNavigate, useResolvedPath, useRoute, useRouter } from \"./routing\";\nimport { joinPaths, normalizePath, createMemoObject } from \"./utils\";\nexport const Router = (props) => {\n    const { source, url, base, data, out } = props;\n    const integration = source || (isServer ? staticIntegration({ value: url || \"\" }) : pathIntegration());\n    const routerState = createRouterContext(integration, base, data, out);\n    return (<RouterContextObj.Provider value={routerState}>{props.children}</RouterContextObj.Provider>);\n};\nexport const Routes = (props) => {\n    const router = useRouter();\n    const parentRoute = useRoute();\n    const routeDefs = children(() => props.children);\n    const branches = createMemo(() => createBranches(routeDefs(), joinPaths(parentRoute.pattern, props.base || \"\"), Outlet));\n    const matches = createMemo(() => getRouteMatches(branches(), router.location.pathname));\n    const params = createMemoObject(() => {\n        const m = matches();\n        const params = {};\n        for (let i = 0; i < m.length; i++) {\n            Object.assign(params, m[i].params);\n        }\n        return params;\n    });\n    if (router.out) {\n        router.out.matches.push(matches().map(({ route, path, params }) => ({\n            originalPath: route.originalPath,\n            pattern: route.pattern,\n            path,\n            params\n        })));\n    }\n    const disposers = [];\n    let root;\n    const routeStates = createMemo(on(matches, (nextMatches, prevMatches, prev) => {\n        let equal = prevMatches && nextMatches.length === prevMatches.length;\n        const next = [];\n        for (let i = 0, len = nextMatches.length; i < len; i++) {\n            const prevMatch = prevMatches && prevMatches[i];\n            const nextMatch = nextMatches[i];\n            if (prev && prevMatch && nextMatch.route.key === prevMatch.route.key) {\n                next[i] = prev[i];\n            }\n            else {\n                equal = false;\n                if (disposers[i]) {\n                    disposers[i]();\n                }\n                createRoot(dispose => {\n                    disposers[i] = dispose;\n                    next[i] = createRouteContext(router, next[i - 1] || parentRoute, () => routeStates()[i + 1], () => matches()[i], params);\n                });\n            }\n        }\n        disposers.splice(nextMatches.length).forEach(dispose => dispose());\n        if (prev && equal) {\n            return prev;\n        }\n        root = next[0];\n        return next;\n    }));\n    return (<Show when={routeStates() && root} keyed>\n      {route => <RouteContextObj.Provider value={route}>{route.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nexport const useRoutes = (routes, base) => {\n    return () => <Routes base={base}>{routes}</Routes>;\n};\nexport const Route = (props) => {\n    const childRoutes = children(() => props.children);\n    return mergeProps(props, {\n        get children() {\n            return childRoutes();\n        }\n    });\n};\nexport const Outlet = () => {\n    const route = useRoute();\n    return (<Show when={route.child} keyed>\n      {child => <RouteContextObj.Provider value={child}>{child.outlet()}</RouteContextObj.Provider>}\n    </Show>);\n};\nexport function A(props) {\n    props = mergeProps({ inactiveClass: \"inactive\", activeClass: \"active\" }, props);\n    const [, rest] = splitProps(props, [\n        \"href\",\n        \"state\",\n        \"class\",\n        \"activeClass\",\n        \"inactiveClass\",\n        \"end\"\n    ]);\n    const to = useResolvedPath(() => props.href);\n    const href = useHref(to);\n    const location = useLocation();\n    const isActive = createMemo(() => {\n        const to_ = to();\n        if (to_ === undefined)\n            return false;\n        const path = normalizePath(to_.split(/[?#]/, 1)[0]).toLowerCase();\n        const loc = normalizePath(location.pathname).toLowerCase();\n        return props.end ? path === loc : loc.startsWith(path);\n    });\n    return (<a link {...rest} href={href() || props.href} state={JSON.stringify(props.state)} classList={{\n            ...(props.class && { [props.class]: true }),\n            [props.inactiveClass]: !isActive(),\n            [props.activeClass]: isActive(),\n            ...rest.classList\n        }} aria-current={isActive() ? \"page\" : undefined}/>);\n}\n// deprecated alias exports\nexport { A as Link, A as NavLink };\nexport function Navigate(props) {\n    const navigate = useNavigate();\n    const location = useLocation();\n    const { href, state } = props;\n    const path = typeof href === \"function\" ? href({ navigate, location }) : href;\n    navigate(path, { replace: true, state });\n    return null;\n}\n","export default \"__VITE_ASSET__7a9131e8__\"","import { A } from '@solidjs/router';\nimport { onCleanup, createSignal } from 'solid-js';\n\nimport { printLog } from '../../utils/utils';\nimport atgLogo from '../../assets/atgLogo.png';\n\ntype Path = {\n  path: string;\n  name: string;\n};\n\ntype HeaderProps = {\n  links: Array<Path>;\n  logo?: string; // A URL to the logo image\n};\n\nconst Header = ({ links }: HeaderProps) => {\n  const [searchInput, setSearchInput] = createSignal('');\n\n  const handleSearch = () => {\n    if (searchInput()) {\n      printLog(`Searching for: ${searchInput()}`);\n      // Perform actual search logic here...\n    }\n  };\n\n  onCleanup(() => {\n    // Cleanup tasks...\n  });\n\n  return (\n    <header style=\"background-color: #333; color: white; padding: 1rem;\">\n      <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n        {<img src={atgLogo} alt=\"Logo\" style=\"height: 50px;\" />}\n\n        <nav>\n          {links.map((link) => (\n            <A href={link.path} style=\"margin: 0 1rem; color: white\">\n              {link.name}\n            </A>\n          ))}\n        </nav>\n\n        <div>\n          <input\n            type=\"text\"\n            placeholder=\"Search...\"\n            value={searchInput()}\n            onInput={(e) =>\n              setSearchInput((e.target as HTMLInputElement).value)\n            }\n          />\n          <button onClick={handleSearch}>Search</button>\n        </div>\n      </div>\n    </header>\n  );\n};\n\nexport default Header;\n"],"names":["bindEvent","target","type","handler","intercept","value","setValue","get","set","v","querySelector","selector","scrollToHash","hash","fallbackTop","el","createIntegration","init","utils","ignore","wrap","signal","createSignal","a","b","next","onCleanup","normalizeIntegration","integration","pathIntegration","replace","scroll","state","notify","delta","createBeforeLeave","listeners","subscribe","listener","confirm","to","options","e","l","force","hasSchemeRegex","trimPathRegex","normalizePath","path","omitSlash","s","resolvePath","base","from","basePath","fromPath","result","invariant","message","extractSearchParams","url","params","key","createMemoObject","fn","map","owner","getOwner","_","property","runWithOwner","createMemo","MAX_REDIRECTS","RouterContextObj","createContext","RouteContextObj","useRouter","useContext","TempRoute","useRoute","useResolvedPath","route","useHref","router","to_","useLocation","createLocation","origin","prev","path_","pathname","search","on","createRouterContext","data","out","source","setSource","parsePath","p","renderPath","beforeLeave","output","isRouting","setIsRouting","start","callback","startTransition","reference","setReference","setState","location","referrers","baseRoute","navigatorFactory","navigateFromRoute","untrack","resolve","nextState","resolvedTo","current","isServer","len","resetErrorBoundaries","navigateEnd","first","createRenderEffect","handleAnchorClick","evt","href","rel","delegateEvents","Router","props","routerState","_$createComponent","Provider","children","A","mergeProps","inactiveClass","activeClass","rest","splitProps","isActive","undefined","split","toLowerCase","loc","end","startsWith","_el$","_tmpl$","_$spread","_$mergeProps","JSON","stringify","classList","class","atgLogo","Header","links","searchInput","setSearchInput","handleSearch","printLog","_el$2","firstChild","_el$3","_el$4","nextSibling","_el$5","_el$6","_$insert","_el$7","_tmpl$2","_$setAttribute","link","style","name","$$input","$$click","_$effect","Header$1","_$delegateEvents"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}